"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
var fs_1 = require("fs");
var path = require("path");
/**
 * Clasp command method bodies.
 */
var chalk_1 = require("chalk");
var commander = require("commander");
var del = require("del");
var pluralize = require("pluralize");
var watch_1 = require("watch");
var apis_1 = require("./apis");
var apiutils_1 = require("./apiutils");
var auth_1 = require("./auth");
var dotfile_1 = require("./dotfile");
var files_1 = require("./files");
var manifest_1 = require("./manifest");
var utils_1 = require("./utils");
var multimatch = require("multimatch");
var ellipsize = require('ellipsize');
var open = require('opn');
var inquirer = require('inquirer');
var padEnd = require('string.prototype.padend');
// setup inquirer
var prompt = inquirer.prompt;
inquirer.registerPrompt('autocomplete', require('inquirer-autocomplete-prompt'));
/**
 * Force downloads all Apps Script project files into the local filesystem.
 * @param cmd.version {number} The version number of the project to retrieve.
 *                             If not provided, the project's HEAD version is returned.
 */
exports.pull = function (cmd) { return __awaiter(_this, void 0, void 0, function () {
    var _a, scriptId, rootDir, files;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, utils_1.checkIfOnline()];
            case 1:
                _b.sent();
                return [4 /*yield*/, utils_1.getProjectSettings()];
            case 2:
                _a = _b.sent(), scriptId = _a.scriptId, rootDir = _a.rootDir;
                if (!scriptId) return [3 /*break*/, 5];
                utils_1.spinner.setSpinnerTitle(utils_1.LOG.PULLING);
                return [4 /*yield*/, files_1.fetchProject(scriptId, cmd.versionNumber)];
            case 3:
                files = _b.sent();
                return [4 /*yield*/, files_1.writeProjectFiles(files, rootDir)];
            case 4:
                _b.sent();
                _b.label = 5;
            case 5: return [2 /*return*/];
        }
    });
}); };
/**
 * Uploads all files into the script.google.com filesystem.
 * TODO: Only push the specific files that changed (rather than all files).
 * @param cmd.watch {boolean} If true, runs `clasp push` when any local file changes. Exit with ^C.
 */
exports.push = function (cmd) { return __awaiter(_this, void 0, void 0, function () {
    var rootDir, manifestHasChanges, confirmManifestUpdate, patterns_1, _a, _b;
    var _this = this;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0: return [4 /*yield*/, utils_1.checkIfOnline()];
            case 1:
                _c.sent();
                return [4 /*yield*/, auth_1.loadAPICredentials()];
            case 2:
                _c.sent();
                return [4 /*yield*/, manifest_1.isValidManifest()];
            case 3:
                _c.sent();
                return [4 /*yield*/, utils_1.getProjectSettings()];
            case 4:
                rootDir = (_c.sent()).rootDir;
                manifestHasChanges = function () { return __awaiter(_this, void 0, void 0, function () {
                    var _a, scriptId, rootDir, localManifestPath, localManifest, remoteFiles, remoteManifest;
                    return __generator(this, function (_b) {
                        switch (_b.label) {
                            case 0: return [4 /*yield*/, utils_1.getProjectSettings()];
                            case 1:
                                _a = _b.sent(), scriptId = _a.scriptId, rootDir = _a.rootDir;
                                localManifestPath = path.join(rootDir || dotfile_1.DOT.PROJECT.DIR, utils_1.PROJECT_MANIFEST_FILENAME);
                                localManifest = fs_1.readFileSync(localManifestPath, 'utf8');
                                return [4 /*yield*/, files_1.fetchProject(scriptId, undefined, true)];
                            case 2:
                                remoteFiles = _b.sent();
                                remoteManifest = remoteFiles.find(function (file) { return file.name === utils_1.PROJECT_MANIFEST_BASENAME; });
                                if (!remoteManifest)
                                    throw Error('remote manifest no found');
                                return [2 /*return*/, localManifest !== remoteManifest.source];
                        }
                    });
                }); };
                confirmManifestUpdate = function () { return __awaiter(_this, void 0, void 0, function () {
                    var answers;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, prompt([{
                                        name: 'overwrite',
                                        type: 'confirm',
                                        message: 'Manifest file has been updated. Do you want to push and overwrite?',
                                        default: false,
                                    }])];
                            case 1:
                                answers = _a.sent();
                                return [2 /*return*/, answers.overwrite];
                        }
                    });
                }); };
                if (!cmd.watch) return [3 /*break*/, 6];
                console.log(utils_1.LOG.PUSH_WATCH);
                return [4 /*yield*/, dotfile_1.DOTFILE.IGNORE()];
            case 5:
                patterns_1 = _c.sent();
                // @see https://www.npmjs.com/package/watch
                watch_1.watchTree(rootDir || '.', function (f, curr, prev) { return __awaiter(_this, void 0, void 0, function () {
                    var _a, _b;
                    return __generator(this, function (_c) {
                        switch (_c.label) {
                            case 0:
                                // The first watch doesn't give a string for some reason.
                                if (typeof f === 'string') {
                                    console.log("\n" + utils_1.LOG.PUSH_WATCH_UPDATED(f) + "\n");
                                    if (multimatch([f], patterns_1).length) {
                                        // The file matches the ignored files patterns so we do nothing
                                        return [2 /*return*/];
                                    }
                                }
                                _b = !cmd.force;
                                if (!_b) return [3 /*break*/, 2];
                                return [4 /*yield*/, manifestHasChanges()];
                            case 1:
                                _b = (_c.sent());
                                _c.label = 2;
                            case 2:
                                _a = _b;
                                if (!_a) return [3 /*break*/, 4];
                                return [4 /*yield*/, confirmManifestUpdate()];
                            case 3:
                                _a = !(_c.sent());
                                _c.label = 4;
                            case 4:
                                if (_a) {
                                    console.log('Stoping push...');
                                    return [2 /*return*/];
                                }
                                console.log(utils_1.LOG.PUSHING);
                                files_1.pushFiles();
                                return [2 /*return*/];
                        }
                    });
                }); });
                return [3 /*break*/, 11];
            case 6:
                _b = !cmd.force;
                if (!_b) return [3 /*break*/, 8];
                return [4 /*yield*/, manifestHasChanges()];
            case 7:
                _b = (_c.sent());
                _c.label = 8;
            case 8:
                _a = _b;
                if (!_a) return [3 /*break*/, 10];
                return [4 /*yield*/, confirmManifestUpdate()];
            case 9:
                _a = !(_c.sent());
                _c.label = 10;
            case 10:
                if (_a) {
                    console.log('Stoping push...');
                    return [2 /*return*/];
                }
                utils_1.spinner.setSpinnerTitle(utils_1.LOG.PUSHING).start();
                files_1.pushFiles();
                _c.label = 11;
            case 11: return [2 /*return*/];
        }
    });
}); };
/**
 * Outputs the help command.
 */
exports.help = function () { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        commander.outputHelp();
        process.exit(0);
        return [2 /*return*/];
    });
}); };
/**
 * Displays a default message when an unknown command is typed.
 * @param command {string} The command that was typed.
 */
exports.defaultCmd = function (command) { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        utils_1.logError(null, utils_1.ERROR.COMMAND_DNE(command));
        return [2 /*return*/];
    });
}); };
/**
 * Creates a new Apps Script project.
 * @param cmd.type {string} The type of the Apps Script project.
 * @param cmd.title {string} The title of the Apps Script project's file
 * @param cmd.parentId {string} The Drive ID of the G Suite doc this script is bound to.
 * @param cmd.rootDir {string} Specifies the local directory in which clasp will store your project files.
 *                    If not specified, clasp will default to the current directory.
 */
exports.create = function (cmd) { return __awaiter(_this, void 0, void 0, function () {
    var _a, title, type, parentId, answers, DRIVE_FILE_MIMETYPES, driveFileType, driveFile, scriptId, err_1, res, createdScriptId, rootDir, files;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: 
            // Handle common errors.
            return [4 /*yield*/, utils_1.checkIfOnline()];
            case 1:
                // Handle common errors.
                _b.sent();
                if (files_1.hasProject())
                    return [2 /*return*/, utils_1.logError(null, utils_1.ERROR.FOLDER_EXISTS)];
                return [4 /*yield*/, auth_1.loadAPICredentials()];
            case 2:
                _b.sent();
                title = cmd.title || utils_1.getDefaultProjectName();
                type = cmd.type;
                parentId = cmd.parentId;
                if (!!type) return [3 /*break*/, 4];
                return [4 /*yield*/, prompt([
                        {
                            type: 'list',
                            name: 'type',
                            message: utils_1.LOG.CLONE_SCRIPT_QUESTION,
                            choices: Object.keys(apis_1.SCRIPT_TYPES).map(function (key) { return apis_1.SCRIPT_TYPES[key]; }),
                        },
                    ])];
            case 3:
                answers = _b.sent();
                type = answers.type;
                _b.label = 4;
            case 4:
                DRIVE_FILE_MIMETYPES = (_a = {},
                    _a[apis_1.SCRIPT_TYPES.DOCS] = 'application/vnd.google-apps.document',
                    _a[apis_1.SCRIPT_TYPES.FORMS] = 'application/vnd.google-apps.form',
                    _a[apis_1.SCRIPT_TYPES.SHEETS] = 'application/vnd.google-apps.spreadsheet',
                    _a[apis_1.SCRIPT_TYPES.SLIDES] = 'application/vnd.google-apps.presentation',
                    _a);
                driveFileType = DRIVE_FILE_MIMETYPES[type];
                if (!driveFileType) return [3 /*break*/, 6];
                utils_1.spinner.setSpinnerTitle(utils_1.LOG.CREATE_DRIVE_FILE_START(type)).start();
                return [4 /*yield*/, auth_1.drive.files.create({
                        requestBody: {
                            mimeType: driveFileType,
                            name: title,
                        },
                    })];
            case 5:
                driveFile = _b.sent();
                parentId = driveFile.data.id || '';
                utils_1.spinner.stop(true);
                console.log(utils_1.LOG.CREATE_DRIVE_FILE_FINISH(type, parentId));
                _b.label = 6;
            case 6:
                // CLI Spinner
                utils_1.spinner.setSpinnerTitle(utils_1.LOG.CREATE_PROJECT_START(title)).start();
                _b.label = 7;
            case 7:
                _b.trys.push([7, 9, , 10]);
                return [4 /*yield*/, utils_1.getProjectSettings(true)];
            case 8:
                scriptId = (_b.sent()).scriptId;
                if (scriptId) {
                    utils_1.logError(null, utils_1.ERROR.NO_NESTED_PROJECTS);
                    process.exit(1);
                }
                return [3 /*break*/, 10];
            case 9:
                err_1 = _b.sent();
                return [3 /*break*/, 10];
            case 10: return [4 /*yield*/, auth_1.script.projects.create({
                    requestBody: {
                        title: title,
                        parentId: parentId,
                    },
                })];
            case 11:
                res = _b.sent();
                utils_1.spinner.stop(true);
                if (!(res.status !== 200)) return [3 /*break*/, 12];
                if (parentId) {
                    console.log(res.statusText, utils_1.ERROR.CREATE_WITH_PARENT);
                }
                utils_1.logError(res.statusText, utils_1.ERROR.CREATE);
                return [3 /*break*/, 14];
            case 12:
                createdScriptId = res.data.scriptId || '';
                console.log(utils_1.LOG.CREATE_PROJECT_FINISH(type, createdScriptId));
                rootDir = cmd.rootDir;
                utils_1.saveProject({
                    scriptId: createdScriptId,
                    rootDir: rootDir,
                }, false);
                if (!!manifest_1.manifestExists()) return [3 /*break*/, 14];
                return [4 /*yield*/, files_1.fetchProject(createdScriptId)];
            case 13:
                files = _b.sent();
                files_1.writeProjectFiles(files, rootDir); // fetches appsscript.json, o.w. `push` breaks
                _b.label = 14;
            case 14: return [2 /*return*/];
        }
    });
}); };
/**
 * Fetches an Apps Script project.
 * Prompts the user if no script ID is provided.
 * @param scriptId {string} The Apps Script project ID to fetch.
 * @param versionNumber {string} An optional version to pull the script from.
 * @param cmd.rootDir {string} Specifies the local directory in which clasp will store your project files.
 *                    If not specified, clasp will default to the current directory.
 */
exports.clone = function (scriptId, versionNumber, cmd) { return __awaiter(_this, void 0, void 0, function () {
    var list_1, data, files_2, fileIds, answers, ids, rootDir, files;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, utils_1.checkIfOnline()];
            case 1:
                _a.sent();
                if (files_1.hasProject())
                    return [2 /*return*/, utils_1.logError(null, utils_1.ERROR.FOLDER_EXISTS)];
                if (!!scriptId) return [3 /*break*/, 5];
                return [4 /*yield*/, auth_1.loadAPICredentials()];
            case 2:
                _a.sent();
                return [4 /*yield*/, auth_1.drive.files.list({
                        // pageSize: 10,
                        // fields: 'files(id, name)',
                        orderBy: 'modifiedByMeTime desc',
                        q: 'mimeType="application/vnd.google-apps.script"',
                    })];
            case 3:
                list_1 = _a.sent();
                data = list_1.data;
                if (!data)
                    return [2 /*return*/, utils_1.logError(list_1.statusText, 'Unable to use the Drive API.')];
                files_2 = data.files;
                if (!files_2 || !files_2.length)
                    return [2 /*return*/, console.log(utils_1.LOG.FINDING_SCRIPTS_DNE)];
                fileIds = files_2.map(function (file) {
                    return {
                        name: padEnd(file.name, 20) + " \u2013 " + utils_1.LOG.SCRIPT_LINK(file.id),
                        value: file.id,
                    };
                });
                return [4 /*yield*/, prompt([
                        {
                            type: 'list',
                            name: 'scriptId',
                            message: utils_1.LOG.CLONE_SCRIPT_QUESTION,
                            choices: fileIds,
                            pageSize: 30,
                        },
                    ])];
            case 4:
                answers = _a.sent();
                scriptId = answers.scriptId;
                _a.label = 5;
            case 5:
                // We have a scriptId or URL
                // If we passed a URL, extract the scriptId from that. For example:
                // https://script.google.com/a/DOMAIN/d/1Ng7bNZ1K95wNi2H7IUwZzM68FL6ffxQhyc_ByV42zpS6qAFX8pFsWu2I/edit
                if (scriptId.length !== 57) {
                    ids = scriptId.split('/').filter(function (s) {
                        return s.length === 57;
                    });
                    if (ids.length) {
                        scriptId = ids[0];
                    }
                }
                utils_1.spinner.setSpinnerTitle(utils_1.LOG.CLONING);
                rootDir = cmd.rootDir;
                utils_1.saveProject({
                    scriptId: scriptId,
                    rootDir: rootDir,
                }, false);
                return [4 /*yield*/, files_1.fetchProject(scriptId, versionNumber)];
            case 6:
                files = _a.sent();
                return [4 /*yield*/, files_1.writeProjectFiles(files, rootDir)];
            case 7:
                _a.sent();
                return [2 /*return*/];
        }
    });
}); };
/**
 * Logs the user in. Saves the client credentials to an either local or global rc file.
 * @param {object} options The login options.
 * @param {boolean?} options.localhost If true, authorizes without a HTTP server.
 * @param {string?} options.creds The location of credentials file.
 */
exports.login = function (options) { return __awaiter(_this, void 0, void 0, function () {
    var isLocalLogin, loggedInLocal, loggedInGlobal, useLocalhost, oauthScopes, manifest, credsFile, credentials;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0:
                isLocalLogin = !!options.creds;
                loggedInLocal = utils_1.hasOauthClientSettings(true);
                loggedInGlobal = utils_1.hasOauthClientSettings(false);
                if (isLocalLogin && loggedInLocal)
                    console.error(utils_1.ERROR.LOGGED_IN_LOCAL);
                if (!isLocalLogin && loggedInGlobal)
                    console.error(utils_1.ERROR.LOGGED_IN_GLOBAL);
                console.log(utils_1.LOG.LOGIN(isLocalLogin));
                return [4 /*yield*/, utils_1.checkIfOnline()];
            case 1:
                _a.sent();
                useLocalhost = !!options.localhost;
                if (!options.creds) return [3 /*break*/, 5];
                oauthScopes = [];
                return [4 /*yield*/, manifest_1.readManifest()];
            case 2:
                manifest = _a.sent();
                oauthScopes = manifest.oauthScopes || [];
                oauthScopes = oauthScopes.concat([
                    'https://www.googleapis.com/auth/script.webapp.deploy',
                ]);
                console.log('');
                console.log("Authorizing with the following scopes:");
                oauthScopes.map(function (scope) {
                    console.log(scope);
                });
                console.log('');
                console.log("NOTE: The full list of scopes you're project may need" +
                    " can be found at script.google.com under:");
                console.log("File > Project Properties > Scopes");
                console.log('');
                credsFile = fs_1.readFileSync(options.creds, 'utf8');
                credentials = JSON.parse(credsFile);
                return [4 /*yield*/, auth_1.authorize({
                        useLocalhost: useLocalhost,
                        creds: credentials,
                        scopes: oauthScopes,
                    })];
            case 3:
                _a.sent();
                return [4 /*yield*/, apiutils_1.enableAppsScriptAPI()];
            case 4:
                _a.sent();
                return [3 /*break*/, 7];
            case 5: 
            // Not using own credentials
            return [4 /*yield*/, auth_1.authorize({
                    useLocalhost: useLocalhost,
                    scopes: [
                        // Use the default scopes needed for clasp.
                        'https://www.googleapis.com/auth/script.deployments',
                        'https://www.googleapis.com/auth/script.projects',
                        'https://www.googleapis.com/auth/script.webapp.deploy',
                        'https://www.googleapis.com/auth/drive.metadata.readonly',
                        'https://www.googleapis.com/auth/drive.file',
                        'https://www.googleapis.com/auth/service.management',
                        'https://www.googleapis.com/auth/logging.read',
                        // Extra scope since service.management doesn't work alone
                        'https://www.googleapis.com/auth/cloud-platform',
                    ],
                })];
            case 6:
                // Not using own credentials
                _a.sent();
                _a.label = 7;
            case 7:
                process.exit(0); // gracefully exit after successful login
                return [2 /*return*/];
        }
    });
}); };
/**
 * Logs out the user by deleting credentials.
 */
exports.logout = function () { return __awaiter(_this, void 0, void 0, function () {
    return __generator(this, function (_a) {
        if (utils_1.hasOauthClientSettings(true))
            del(dotfile_1.DOT.RC.ABSOLUTE_LOCAL_PATH, { force: true });
        // del doesn't work with a relative path (~)
        if (utils_1.hasOauthClientSettings())
            del(dotfile_1.DOT.RC.ABSOLUTE_PATH, { force: true });
        return [2 /*return*/];
    });
}); };
/**
 * Prints StackDriver logs from this Apps Script project.
 * @param cmd.json {boolean} If true, the command will output logs as json.
 * @param cmd.open {boolean} If true, the command will open the StackDriver logs website.
 * @param cmd.setup {boolean} If true, the command will help you setup logs.
 * @param cmd.watch {boolean} If true, the command will watch for logs and print them. Exit with ^C.
 */
exports.logs = function (cmd) { return __awaiter(_this, void 0, void 0, function () {
    /**
     * Prints log entries
     * @param entries {any[]} StackDriver log entries.
     */
    function printLogs(entries) {
        if (entries === void 0) { entries = []; }
        entries = entries.reverse(); // print in syslog ascending order
        for (var i = 0; i < 50 && entries ? i < entries.length : i < 0; ++i) {
            var _a = entries[i], severity = _a.severity, timestamp = _a.timestamp, resource = _a.resource, textPayload = _a.textPayload, protoPayload = _a.protoPayload, jsonPayload = _a.jsonPayload, insertId = _a.insertId;
            var functionName = resource.labels.function_name;
            functionName = functionName ? padEnd(functionName, 15) : utils_1.ERROR.NO_FUNCTION_NAME;
            var payloadData = '';
            if (cmd.json) {
                payloadData = JSON.stringify(entries[i], null, 2);
            }
            else {
                var data = {
                    textPayload: textPayload,
                    // chokes on unmatched json payloads
                    // jsonPayload: jsonPayload ? jsonPayload.fields.message.stringValue : '',
                    jsonPayload: jsonPayload ? JSON.stringify(jsonPayload).substr(0, 255) : '',
                    protoPayload: protoPayload,
                };
                payloadData = data.textPayload || data.jsonPayload || data.protoPayload || utils_1.ERROR.PAYLOAD_UNKNOWN;
                if (payloadData && payloadData['@type'] === 'type.googleapis.com/google.cloud.audit.AuditLog') {
                    payloadData = utils_1.LOG.STACKDRIVER_SETUP;
                    functionName = padEnd(protoPayload.methodName, 15);
                }
                if (payloadData && typeof payloadData === 'string') {
                    payloadData = padEnd(payloadData, 20);
                }
            }
            var coloredStringMap = {
                ERROR: chalk_1.default.red(severity),
                INFO: chalk_1.default.cyan(severity),
                DEBUG: chalk_1.default.green(severity),
                NOTICE: chalk_1.default.magenta(severity),
                WARNING: chalk_1.default.yellow(severity),
            };
            var coloredSeverity = coloredStringMap[severity] || severity;
            coloredSeverity = padEnd(String(coloredSeverity), 20);
            // If we haven't logged this entry before, log it and mark the cache.
            if (!logEntryCache[insertId]) {
                console.log(coloredSeverity + " " + timestamp + " " + functionName + " " + payloadData);
                logEntryCache[insertId] = true;
            }
        }
    }
    function setupLogs(projectId) {
        return __awaiter(this, void 0, void 0, function () {
            var promise;
            return __generator(this, function (_a) {
                promise = new Promise(function (resolve, reject) {
                    utils_1.getProjectSettings().then(function (projectSettings) {
                        console.log("Open this link: " + utils_1.LOG.SCRIPT_LINK(projectSettings.scriptId) + "\n");
                        console.log("Go to *Resource > Cloud Platform Project...* and copy your projectId\n(including \"project-id-\")\n");
                        prompt([
                            {
                                type: 'input',
                                name: 'projectId',
                                message: 'What is your GCP projectId?',
                            },
                        ])
                            .then(function (answers) {
                            projectId = answers.projectId;
                            var dotfile = dotfile_1.DOTFILE.PROJECT();
                            if (!dotfile)
                                return reject(utils_1.logError(null, utils_1.ERROR.SETTINGS_DNE));
                            dotfile
                                .read()
                                .then(function (settings) {
                                if (!settings.scriptId)
                                    utils_1.logError(utils_1.ERROR.SCRIPT_ID_DNE);
                                dotfile.write(Object.assign(settings, { projectId: projectId }));
                                resolve(projectId);
                            })
                                .catch(function (err) {
                                reject(utils_1.logError(err));
                            });
                        })
                            .catch(function (err) {
                            reject(console.log(err));
                        });
                    });
                });
                promise.catch(function (err) {
                    utils_1.logError(err);
                    utils_1.spinner.stop(true);
                });
                return [2 /*return*/, promise];
            });
        });
    }
    /**
     * Fetches the logs and prints the to the user.
     * @param startDate {Date?} Get logs from this date to now.
     */
    function fetchAndPrintLogs(startDate) {
        return __awaiter(this, void 0, void 0, function () {
            var filter, logs;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        utils_1.spinner.setSpinnerTitle("" + (oauthSettings.isLocalCreds ? utils_1.LOG.LOCAL_CREDS : '') + utils_1.LOG.GRAB_LOGS).start();
                        filter = '';
                        if (startDate) {
                            filter = "timestamp >= \"" + startDate.toISOString() + "\"";
                        }
                        return [4 /*yield*/, auth_1.logger.entries.list({
                                requestBody: {
                                    resourceNames: ["projects/" + projectId],
                                    filter: filter,
                                    orderBy: 'timestamp desc',
                                },
                            })];
                    case 1:
                        logs = _a.sent();
                        // We have an API response. Now, check the API response status.
                        utils_1.spinner.stop(true);
                        // Only print filter if provided.
                        if (filter.length) {
                            console.log(filter);
                        }
                        if (logs.status !== 200) {
                            switch (logs.status) {
                                case 401:
                                    utils_1.logError(null, oauthSettings.isLocalCreds ? utils_1.ERROR.UNAUTHENTICATED_LOCAL : utils_1.ERROR.UNAUTHENTICATED);
                                case 403:
                                    utils_1.logError(null, oauthSettings.isLocalCreds ? utils_1.ERROR.PERMISSION_DENIED_LOCAL : utils_1.ERROR.PERMISSION_DENIED);
                                default:
                                    utils_1.logError(null, "(" + logs.status + ") Error: " + logs.statusText);
                            }
                        }
                        else {
                            printLogs(logs.data.entries);
                        }
                        return [2 /*return*/];
                }
            });
        });
    }
    var logEntryCache, projectId, _a, url, oauthSettings, POLL_INTERVAL_1;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, utils_1.checkIfOnline()];
            case 1:
                _b.sent();
                logEntryCache = {};
                return [4 /*yield*/, utils_1.getProjectSettings()];
            case 2:
                projectId = (_b.sent()).projectId;
                if (!cmd.setup) return [3 /*break*/, 4];
                return [4 /*yield*/, setupLogs()];
            case 3:
                _a = _b.sent();
                return [3 /*break*/, 5];
            case 4:
                _a = projectId;
                _b.label = 5;
            case 5:
                projectId = _a;
                if (!!projectId) return [3 /*break*/, 7];
                console.log(utils_1.LOG.NO_GCLOUD_PROJECT);
                return [4 /*yield*/, setupLogs()];
            case 6:
                projectId = _b.sent();
                console.log(utils_1.LOG.LOGS_SETUP);
                _b.label = 7;
            case 7:
                // If we're opening the logs, get the URL, open, then quit.
                if (cmd.open) {
                    url = utils_1.URL.LOGS(projectId);
                    console.log("Opening logs: " + url);
                    return [2 /*return*/, open(url, { wait: false })];
                }
                return [4 /*yield*/, auth_1.loadAPICredentials()];
            case 8:
                oauthSettings = _b.sent();
                if (cmd.watch) {
                    POLL_INTERVAL_1 = 6000;
                    setInterval(function () {
                        var startDate = new Date();
                        startDate.setSeconds(startDate.getSeconds() - (10 * POLL_INTERVAL_1) / 1000);
                        fetchAndPrintLogs(startDate);
                    }, POLL_INTERVAL_1);
                }
                else {
                    fetchAndPrintLogs();
                }
                return [2 /*return*/];
        }
    });
}); };
/**
 * Executes an Apps Script function. Requires clasp login --creds.
 * @param functionName {string} The function name within the Apps Script project.
 * @param cmd.nondev {boolean} If we want to run the last deployed version vs the latest code.
 * @see https://developers.google.com/apps-script/api/how-tos/execute
 * @requires `clasp login --creds` to be run beforehand.
 */
exports.run = function (functionName, cmd) { return __awaiter(_this, void 0, void 0, function () {
    function IsValidJSONString(str) {
        try {
            JSON.parse(str);
        }
        catch (error) {
            throw new Error('Error: Input params not Valid JSON string. Please fix and try again');
        }
        return true;
    }
    /**
     * Runs a function.
     * @see https://developers.google.com/apps-script/api/reference/rest/v1/scripts/run#response-body
     */
    function runFunction(functionName, params) {
        return __awaiter(this, void 0, void 0, function () {
            var localScript, res, data, err_2, readline, scopes_1, rl_1;
            var _this = this;
            return __generator(this, function (_a) {
                switch (_a.label) {
                    case 0:
                        _a.trys.push([0, 4, , 5]);
                        // Load local credentials.
                        return [4 /*yield*/, auth_1.loadAPICredentials(true)];
                    case 1:
                        // Load local credentials.
                        _a.sent();
                        return [4 /*yield*/, auth_1.getLocalScript()];
                    case 2:
                        localScript = _a.sent();
                        utils_1.spinner.setSpinnerTitle("Running function: " + functionName).start();
                        return [4 /*yield*/, localScript.scripts.run({
                                scriptId: scriptId,
                                requestBody: {
                                    function: functionName,
                                    parameters: params,
                                    devMode: devMode,
                                },
                            })];
                    case 3:
                        res = _a.sent();
                        utils_1.spinner.stop(true);
                        if (!res || !res.data.done) {
                            utils_1.logError(null, utils_1.ERROR.RUN_NODATA);
                            process.exit(0); // exit gracefully in case localhost server spun up for authorize
                        }
                        data = res.data;
                        // @see https://developers.google.com/apps-script/api/reference/rest/v1/scripts/run#response-body
                        if (data.response) {
                            if (data.response.result) {
                                console.log(data.response.result);
                            }
                            else {
                                console.log(chalk_1.default.red('No response.'));
                            }
                        }
                        else if (data.error && data.error.details) {
                            // @see https://developers.google.com/apps-script/api/reference/rest/v1/scripts/run#Status
                            console.error("" + chalk_1.default.red('Exception:'), data.error.details[0].errorType, data.error.details[0].errorMessage, data.error.details[0].scriptStackTraceElements || []);
                        }
                        return [3 /*break*/, 5];
                    case 4:
                        err_2 = _a.sent();
                        utils_1.spinner.stop(true);
                        if (err_2) {
                            // TODO move these to logError when stable?
                            switch (err_2.code) {
                                case 401:
                                    // The 401 is probably due to this error:
                                    // "Error: Local client credentials unauthenticated. Check scopes/authorization.""
                                    // This is probably due to the OAuth client not having authorized scopes.
                                    console.log("" +
                                        ("Hey! It looks like you aren't authenticated for the scopes required by this script.\nPlease enter the scopes by doing the following:\n1. Open Your Script: " + utils_1.URL.SCRIPT(scriptId) + "\n2. File > Project Properties > Scopes\n3. Copy/Paste the list of scopes here:\n              ~ Example ~\nhttps://mail.google.com/\nhttps://www.googleapis.com/auth/presentations\n----(When you're done, press <Enter> 2x)----"));
                                    readline = require('readline');
                                    scopes_1 = [];
                                    rl_1 = readline.createInterface({
                                        input: process.stdin,
                                        output: process.stdout,
                                        prompt: '',
                                    });
                                    rl_1.prompt();
                                    rl_1.on('line', function (cmd) {
                                        if (cmd === '') {
                                            rl_1.close();
                                        }
                                        else {
                                            scopes_1.push(cmd);
                                        }
                                    });
                                    rl_1.on('close', function () { return __awaiter(_this, void 0, void 0, function () {
                                        var numScopes;
                                        return __generator(this, function (_a) {
                                            switch (_a.label) {
                                                case 0: return [4 /*yield*/, manifest_1.addScopeToManifest(scopes_1)];
                                                case 1:
                                                    _a.sent();
                                                    numScopes = scopes_1.length;
                                                    console.log("Added " + numScopes + " " +
                                                        (pluralize('scope', numScopes) + " to your appsscript.json' oauthScopes"));
                                                    console.log('Please `clasp login --creds <file>` to log in with these new scopes.');
                                                    return [2 /*return*/];
                                            }
                                        });
                                    }); });
                                    // We probably don't need to show the unauth error
                                    // since we always prompt the user to fix this now.
                                    // logError(null, ERROR.UNAUTHENTICATED_LOCAL);
                                    break;
                                case 403:
                                    utils_1.logError(null, utils_1.ERROR.PERMISSION_DENIED_LOCAL);
                                    break;
                                case 404:
                                    utils_1.logError(null, utils_1.ERROR.EXECUTE_ENTITY_NOT_FOUND);
                                    break;
                                default:
                                    utils_1.logError(null, "(" + err_2.code + ") Error: " + err_2.message);
                            }
                        }
                        return [3 /*break*/, 5];
                    case 5: return [2 /*return*/];
                }
            });
        });
    }
    var scriptId, devMode, _a, paramString, params;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, utils_1.checkIfOnline()];
            case 1:
                _b.sent();
                return [4 /*yield*/, auth_1.loadAPICredentials()];
            case 2:
                _b.sent();
                return [4 /*yield*/, utils_1.getProjectSettings(true)];
            case 3:
                scriptId = (_b.sent()).scriptId;
                devMode = !cmd.nondev;
                _a = cmd.params, paramString = _a === void 0 ? '[]' : _a;
                IsValidJSONString(paramString);
                params = JSON.parse(paramString);
                // Ensures the manifest is correct for running a function.
                // The manifest must include:
                // "executionApi": {
                //   "access": "MYSELF"
                // }
                return [4 /*yield*/, manifest_1.isValidManifest()];
            case 4:
                // Ensures the manifest is correct for running a function.
                // The manifest must include:
                // "executionApi": {
                //   "access": "MYSELF"
                // }
                _b.sent();
                // TODO COMMENT THIS. This uses a method that gives a HTML 404.
                // await enableExecutionAPI();
                // Pushes the latest code if in dev mode.
                // We need to update the manifest before executing to:
                // - Ensure the execution API is enambled.
                // - Ensure we can run functions that were developed locally but not pushed.
                if (devMode) {
                    // TODO enable this once we can properly await pushFiles
                    // await pushFiles(true);
                }
                if (!!functionName) return [3 /*break*/, 6];
                return [4 /*yield*/, apiutils_1.getFunctionNames(auth_1.script, scriptId)];
            case 5:
                functionName = _b.sent();
                _b.label = 6;
            case 6: return [4 /*yield*/, runFunction(functionName, params)];
            case 7:
                _b.sent();
                return [2 /*return*/];
        }
    });
}); };
/**
 * Deploys an Apps Script project.
 * @param cmd.versionNumber {string} The project version to deploy at.
 * @param cmd.desc {string} The deployment description.
 * @param cmd.deploymentId  {string} The deployment ID to redeploy.
 */
exports.deploy = function (cmd) { return __awaiter(_this, void 0, void 0, function () {
    var scriptId, versionNumber, _a, description, deploymentId, version_1, deployments;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, utils_1.checkIfOnline()];
            case 1:
                _b.sent();
                return [4 /*yield*/, auth_1.loadAPICredentials()];
            case 2:
                _b.sent();
                return [4 /*yield*/, utils_1.getProjectSettings()];
            case 3:
                scriptId = (_b.sent()).scriptId;
                if (!scriptId)
                    return [2 /*return*/];
                utils_1.spinner.setSpinnerTitle(utils_1.LOG.DEPLOYMENT_START(scriptId)).start();
                versionNumber = cmd.versionNumber;
                _a = cmd.description, description = _a === void 0 ? '' : _a, deploymentId = cmd.deploymentId;
                if (!!versionNumber) return [3 /*break*/, 5];
                return [4 /*yield*/, auth_1.script.projects.versions.create({
                        scriptId: scriptId,
                        requestBody: {
                            description: description,
                        },
                    })];
            case 4:
                version_1 = _b.sent();
                utils_1.spinner.stop(true);
                if (version_1.status !== 200) {
                    return [2 /*return*/, utils_1.logError(null, utils_1.ERROR.ONE_DEPLOYMENT_CREATE)];
                }
                versionNumber = version_1.data.versionNumber || 0;
                console.log(utils_1.LOG.VERSION_CREATED(versionNumber));
                _b.label = 5;
            case 5:
                utils_1.spinner.setSpinnerTitle(utils_1.LOG.DEPLOYMENT_CREATE);
                if (!!deploymentId) return [3 /*break*/, 7];
                return [4 /*yield*/, auth_1.script.projects.deployments.create({
                        scriptId: scriptId,
                        requestBody: {
                            versionNumber: versionNumber,
                            manifestFileName: utils_1.PROJECT_MANIFEST_BASENAME,
                            description: description,
                        },
                    })];
            case 6:
                // if no deploymentId, create a new deployment
                deployments = _b.sent();
                return [3 /*break*/, 9];
            case 7: return [4 /*yield*/, auth_1.script.projects.deployments.update({
                    scriptId: scriptId,
                    deploymentId: deploymentId,
                    requestBody: {
                        deploymentConfig: {
                            versionNumber: versionNumber,
                            manifestFileName: utils_1.PROJECT_MANIFEST_BASENAME,
                            description: description,
                        },
                    },
                })];
            case 8:
                // elseif, update deployment
                deployments = _b.sent();
                _b.label = 9;
            case 9:
                utils_1.spinner.stop(true);
                if (deployments.status !== 200) {
                    utils_1.logError(null, utils_1.ERROR.DEPLOYMENT_COUNT);
                }
                else {
                    console.log("- " + deployments.data.deploymentId + " @" + versionNumber + ".");
                }
                return [2 /*return*/];
        }
    });
}); };
/**
 * Removes a deployment from the Apps Script project.
 * @param deploymentId {string} The deployment's ID
 */
exports.undeploy = function (deploymentId, cmd) { return __awaiter(_this, void 0, void 0, function () {
    var scriptId, deploymentsList, deployments_2, _i, deployments_1, deployment_1, deploymentId_1, result, deploymentsList, deployments_3, deployment;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, utils_1.checkIfOnline()];
            case 1:
                _a.sent();
                return [4 /*yield*/, auth_1.loadAPICredentials()];
            case 2:
                _a.sent();
                return [4 /*yield*/, utils_1.getProjectSettings()];
            case 3:
                scriptId = (_a.sent()).scriptId;
                if (!scriptId)
                    return [2 /*return*/];
                if (!cmd.all) return [3 /*break*/, 9];
                return [4 /*yield*/, auth_1.script.projects.deployments.list({
                        scriptId: scriptId,
                    })];
            case 4:
                deploymentsList = _a.sent();
                if (deploymentsList.status !== 200) {
                    return [2 /*return*/, utils_1.logError(deploymentsList.statusText)];
                }
                deployments_2 = deploymentsList.data.deployments || [];
                if (!deployments_2.length) {
                    utils_1.logError(null, utils_1.ERROR.SCRIPT_ID_INCORRECT(scriptId));
                }
                deployments_2.shift(); // @HEAD (Read-only deployments) may not be deleted.
                _i = 0, deployments_1 = deployments_2;
                _a.label = 5;
            case 5:
                if (!(_i < deployments_1.length)) return [3 /*break*/, 8];
                deployment_1 = deployments_1[_i];
                deploymentId_1 = deployment_1.deploymentId || '';
                utils_1.spinner.setSpinnerTitle(utils_1.LOG.UNDEPLOYMENT_START(deploymentId_1)).start();
                return [4 /*yield*/, auth_1.script.projects.deployments.delete({
                        scriptId: scriptId,
                        deploymentId: deploymentId_1,
                    })];
            case 6:
                result = _a.sent();
                utils_1.spinner.stop(true);
                if (result.status !== 200) {
                    return [2 /*return*/, utils_1.logError(null, utils_1.ERROR.READ_ONLY_DELETE)];
                }
                console.log(utils_1.LOG.UNDEPLOYMENT_FINISH(deploymentId_1));
                _a.label = 7;
            case 7:
                _i++;
                return [3 /*break*/, 5];
            case 8:
                console.log(utils_1.LOG.UNDEPLOYMENT_ALL_FINISH);
                return [2 /*return*/];
            case 9:
                if (!!deploymentId) return [3 /*break*/, 11];
                return [4 /*yield*/, auth_1.script.projects.deployments.list({
                        scriptId: scriptId,
                    })];
            case 10:
                deploymentsList = _a.sent();
                if (deploymentsList.status !== 200) {
                    return [2 /*return*/, utils_1.logError(deploymentsList.statusText)];
                }
                deployments_3 = deploymentsList.data.deployments || [];
                if (!deployments_3.length) {
                    utils_1.logError(null, utils_1.ERROR.SCRIPT_ID_INCORRECT(scriptId));
                }
                if (deployments_3.length <= 1) {
                    // @HEAD (Read-only deployments) may not be deleted.
                    utils_1.logError(null, utils_1.ERROR.NO_VERSIONED_DEPLOYMENTS);
                }
                deploymentId = deployments_3[deployments_3.length - 1].deploymentId || '';
                _a.label = 11;
            case 11:
                utils_1.spinner.setSpinnerTitle(utils_1.LOG.UNDEPLOYMENT_START(deploymentId)).start();
                return [4 /*yield*/, auth_1.script.projects.deployments.delete({
                        scriptId: scriptId,
                        deploymentId: deploymentId,
                    })];
            case 12:
                deployment = _a.sent();
                utils_1.spinner.stop(true);
                if (deployment.status !== 200) {
                    return [2 /*return*/, utils_1.logError(null, utils_1.ERROR.READ_ONLY_DELETE)];
                }
                else {
                    console.log(utils_1.LOG.UNDEPLOYMENT_FINISH(deploymentId));
                }
                return [2 /*return*/];
        }
    });
}); };
/**
 * Lists a user's Apps Script projects using Google Drive.
 */
exports.list = function () { return __awaiter(_this, void 0, void 0, function () {
    var filesList, files, NAME_PAD_SIZE;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, utils_1.checkIfOnline()];
            case 1:
                _a.sent();
                return [4 /*yield*/, auth_1.loadAPICredentials()];
            case 2:
                _a.sent();
                utils_1.spinner.setSpinnerTitle(utils_1.LOG.FINDING_SCRIPTS).start();
                return [4 /*yield*/, auth_1.drive.files.list({
                        pageSize: 50,
                        // fields isn't currently supported
                        // https://github.com/googleapis/google-api-nodejs-client/issues/1374
                        // fields: 'nextPageToken, files(id, name)',
                        q: 'mimeType="application/vnd.google-apps.script"',
                    })];
            case 3:
                filesList = _a.sent();
                utils_1.spinner.stop(true);
                if (filesList.status !== 200) {
                    return [2 /*return*/, utils_1.logError(null, utils_1.ERROR.DRIVE)];
                }
                files = filesList.data.files || [];
                if (!files.length) {
                    return [2 /*return*/, console.log(utils_1.LOG.FINDING_SCRIPTS_DNE)];
                }
                NAME_PAD_SIZE = 20;
                files.map(function (file) {
                    console.log(padEnd(ellipsize(file.name, NAME_PAD_SIZE), NAME_PAD_SIZE) + " \u2013 " + utils_1.URL.SCRIPT(file.id));
                });
                return [2 /*return*/];
        }
    });
}); };
/**
 * Lists a script's deployments.
 */
exports.deployments = function () { return __awaiter(_this, void 0, void 0, function () {
    var scriptId, deployments, deploymentsList, numDeployments, deploymentWord;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, utils_1.checkIfOnline()];
            case 1:
                _a.sent();
                return [4 /*yield*/, auth_1.loadAPICredentials()];
            case 2:
                _a.sent();
                return [4 /*yield*/, utils_1.getProjectSettings()];
            case 3:
                scriptId = (_a.sent()).scriptId;
                if (!scriptId)
                    return [2 /*return*/];
                utils_1.spinner.setSpinnerTitle(utils_1.LOG.DEPLOYMENT_LIST(scriptId)).start();
                return [4 /*yield*/, auth_1.script.projects.deployments.list({
                        scriptId: scriptId,
                    })];
            case 4:
                deployments = _a.sent();
                utils_1.spinner.stop(true);
                if (deployments.status !== 200) {
                    return [2 /*return*/, utils_1.logError(deployments.statusText)];
                }
                deploymentsList = deployments.data.deployments || [];
                numDeployments = deploymentsList.length;
                deploymentWord = pluralize('Deployment', numDeployments);
                console.log(numDeployments + " " + deploymentWord + ".");
                deploymentsList.map(function (_a) {
                    var deploymentId = _a.deploymentId, deploymentConfig = _a.deploymentConfig;
                    var versionString = !!deploymentConfig.versionNumber ? "@" + deploymentConfig.versionNumber : '@HEAD';
                    var description = deploymentConfig.description ? '- ' + deploymentConfig.description : '';
                    console.log("- " + deploymentId + " " + versionString + " " + description);
                });
                return [2 /*return*/];
        }
    });
}); };
/**
 * Lists versions of an Apps Script project.
 */
exports.versions = function () { return __awaiter(_this, void 0, void 0, function () {
    var scriptId, versions, data, numVersions;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, utils_1.checkIfOnline()];
            case 1:
                _a.sent();
                return [4 /*yield*/, auth_1.loadAPICredentials()];
            case 2:
                _a.sent();
                utils_1.spinner.setSpinnerTitle('Grabbing versions...').start();
                return [4 /*yield*/, utils_1.getProjectSettings()];
            case 3:
                scriptId = (_a.sent()).scriptId;
                return [4 /*yield*/, auth_1.script.projects.versions.list({
                        scriptId: scriptId,
                        pageSize: 500,
                    })];
            case 4:
                versions = _a.sent();
                utils_1.spinner.stop(true);
                if (versions.status !== 200) {
                    return [2 /*return*/, utils_1.logError(versions.statusText)];
                }
                data = versions.data;
                if (!data || !data.versions || !data.versions.length) {
                    return [2 /*return*/, utils_1.logError(null, utils_1.LOG.DEPLOYMENT_DNE)];
                }
                numVersions = data.versions.length;
                console.log(utils_1.LOG.VERSION_NUM(numVersions));
                data.versions.reverse().map(function (version) {
                    console.log(utils_1.LOG.VERSION_DESCRIPTION(version));
                });
                return [2 /*return*/];
        }
    });
}); };
/**
 * Creates a new version of an Apps Script project.
 */
exports.version = function (description) { return __awaiter(_this, void 0, void 0, function () {
    var scriptId, answers, versions;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, utils_1.checkIfOnline()];
            case 1:
                _a.sent();
                return [4 /*yield*/, auth_1.loadAPICredentials()];
            case 2:
                _a.sent();
                return [4 /*yield*/, utils_1.getProjectSettings()];
            case 3:
                scriptId = (_a.sent()).scriptId;
                if (!!description) return [3 /*break*/, 5];
                return [4 /*yield*/, prompt([
                        {
                            type: 'input',
                            name: 'description',
                            message: utils_1.LOG.GIVE_DESCRIPTION,
                            default: '',
                        },
                    ])];
            case 4:
                answers = _a.sent();
                description = answers.description;
                _a.label = 5;
            case 5:
                utils_1.spinner.setSpinnerTitle(utils_1.LOG.VERSION_CREATE).start();
                return [4 /*yield*/, auth_1.script.projects.versions.create({
                        scriptId: scriptId,
                        requestBody: {
                            description: description,
                        },
                    })];
            case 6:
                versions = _a.sent();
                utils_1.spinner.stop(true);
                if (versions.status !== 200) {
                    return [2 /*return*/, utils_1.logError(versions.statusText)];
                }
                console.log(utils_1.LOG.VERSION_CREATED(versions.data.versionNumber || -1));
                return [2 /*return*/];
        }
    });
}); };
/**
 * Displays the status of which Apps Script files are ignored from .claspignore
 * @param cmd.json {boolean} Displays the status in json format.
 */
exports.status = function (cmd) { return __awaiter(_this, void 0, void 0, function () {
    var _a, scriptId, rootDir;
    return __generator(this, function (_b) {
        switch (_b.label) {
            case 0: return [4 /*yield*/, utils_1.checkIfOnline()];
            case 1:
                _b.sent();
                return [4 /*yield*/, manifest_1.isValidManifest()];
            case 2:
                _b.sent();
                return [4 /*yield*/, utils_1.getProjectSettings()];
            case 3:
                _a = _b.sent(), scriptId = _a.scriptId, rootDir = _a.rootDir;
                if (!scriptId)
                    return [2 /*return*/];
                files_1.getProjectFiles(rootDir, function (err, projectFiles) {
                    if (err)
                        return console.log(err);
                    if (projectFiles) {
                        var filesToPush = projectFiles[0], untrackedFiles = projectFiles[1];
                        if (cmd.json) {
                            console.log(JSON.stringify({ filesToPush: filesToPush, untrackedFiles: untrackedFiles }));
                        }
                        else {
                            console.log(utils_1.LOG.STATUS_PUSH);
                            filesToPush.forEach(function (file) { return console.log("\u2514\u2500 " + file); });
                            console.log(); // Separate Ignored files list.
                            console.log(utils_1.LOG.STATUS_IGNORE);
                            untrackedFiles.forEach(function (file) { return console.log("\u2514\u2500 " + file); });
                        }
                    }
                });
                return [2 /*return*/];
        }
    });
}); };
/**
 * Opens an Apps Script project's script.google.com editor.
 * @param scriptId {string} The Apps Script project to open.
 * @param cmd.webapp {boolean} If true, the command will open the webapps URL.
 * @param cmd.creds {boolean} If true, the command will open the credentials URL.
 */
exports.openCmd = function (scriptId, cmd) { return __awaiter(_this, void 0, void 0, function () {
    var projectSettings, projectId, deploymentsList, deployments, choices, answers;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, utils_1.checkIfOnline()];
            case 1:
                _a.sent();
                return [4 /*yield*/, utils_1.getProjectSettings()];
            case 2:
                projectSettings = _a.sent();
                if (!scriptId)
                    scriptId = projectSettings.scriptId;
                if (scriptId.length < 30) {
                    return [2 /*return*/, utils_1.logError(null, utils_1.ERROR.SCRIPT_ID_INCORRECT(scriptId))];
                }
                // We've specified to open creds.
                if (cmd.creds) {
                    projectId = projectSettings.projectId;
                    if (!projectId) {
                        return [2 /*return*/, utils_1.logError(null, utils_1.ERROR.NO_GCLOUD_PROJECT)];
                    }
                    console.log(utils_1.LOG.OPEN_CREDS(projectId));
                    return [2 /*return*/, open(utils_1.URL.CREDS(projectId), { wait: false })];
                }
                // If we're not a web app, open the script URL.
                if (!cmd.webapp) {
                    console.log(utils_1.LOG.OPEN_PROJECT(scriptId));
                    return [2 /*return*/, open(utils_1.URL.SCRIPT(scriptId), { wait: false })];
                }
                // Web app: Otherwise, open the latest deployment.
                return [4 /*yield*/, auth_1.loadAPICredentials()];
            case 3:
                // Web app: Otherwise, open the latest deployment.
                _a.sent();
                return [4 /*yield*/, auth_1.script.projects.deployments.list({
                        scriptId: scriptId,
                    })];
            case 4:
                deploymentsList = _a.sent();
                if (deploymentsList.status !== 200) {
                    return [2 /*return*/, utils_1.logError(deploymentsList.statusText)];
                }
                deployments = deploymentsList.data.deployments || [];
                if (!deployments.length) {
                    utils_1.logError(null, utils_1.ERROR.SCRIPT_ID_INCORRECT(scriptId));
                }
                choices = deployments
                    .sort(function (d1, d2) { return d1.updateTime.localeCompare(d2.updateTime); })
                    .map(function (deployment) {
                    var DESC_PAD_SIZE = 30;
                    var id = deployment.deploymentId;
                    var description = deployment.deploymentConfig.description;
                    var versionNumber = deployment.deploymentConfig.versionNumber;
                    return {
                        name: padEnd(ellipsize(description || '', DESC_PAD_SIZE), DESC_PAD_SIZE) +
                            ("@" + padEnd(versionNumber || 'HEAD', 4) + " - " + id),
                        value: deployment,
                    };
                });
                return [4 /*yield*/, prompt([
                        {
                            type: 'list',
                            name: 'deployment',
                            message: 'Open which deployment?',
                            choices: choices,
                        },
                    ])];
            case 5:
                answers = _a.sent();
                console.log(utils_1.LOG.OPEN_WEBAPP(answers.deployment.deploymentId));
                open(utils_1.getWebApplicationURL(answers.deployment), { wait: false });
                return [2 /*return*/];
        }
    });
}); };
/**
 * Acts as a router to apis subcommands
 * Calls functions for list, enable, or disable
 * Otherwise returns an error of command not supported
 */
exports.apis = function (options) { return __awaiter(_this, void 0, void 0, function () {
    var subcommand, serviceName, apisUrl, _a, _b, command;
    var _this = this;
    return __generator(this, function (_c) {
        switch (_c.label) {
            case 0: return [4 /*yield*/, auth_1.loadAPICredentials()];
            case 1:
                _c.sent();
                subcommand = process.argv[3];
                serviceName = process.argv[4];
                if (!options.open) return [3 /*break*/, 3];
                _b = (_a = utils_1.URL).APIS;
                return [4 /*yield*/, utils_1.getProjectId()];
            case 2:
                apisUrl = _b.apply(_a, [_c.sent()]);
                console.log(apisUrl);
                return [2 /*return*/, open(apisUrl, { wait: false })];
            case 3:
                command = {
                    enable: function () { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            apiutils_1.enableOrDisableAPI(serviceName, true);
                            return [2 /*return*/];
                        });
                    }); },
                    disable: function () { return __awaiter(_this, void 0, void 0, function () {
                        return __generator(this, function (_a) {
                            apiutils_1.enableOrDisableAPI(serviceName, false);
                            return [2 /*return*/];
                        });
                    }); },
                    list: function () { return __awaiter(_this, void 0, void 0, function () {
                        var projectId, MAX_PAGE_SIZE, list, serviceList, enabledAPIs, _i, enabledAPIs_1, enabledAPI, name, data, services, PUBLIC_ADVANCED_SERVICE_IDS, publicServices, _loop_1, _a, PUBLIC_ADVANCED_SERVICE_IDS_1, publicServiceId, _b, publicServices_1, api;
                        return __generator(this, function (_c) {
                            switch (_c.label) {
                                case 0: return [4 /*yield*/, utils_1.checkIfOnline()];
                                case 1:
                                    _c.sent();
                                    /**
                                     * List currently enabled APIs.
                                     */
                                    console.log('\n# Currently enabled APIs:');
                                    return [4 /*yield*/, utils_1.getProjectId()];
                                case 2:
                                    projectId = _c.sent();
                                    MAX_PAGE_SIZE = 200;
                                    return [4 /*yield*/, auth_1.serviceUsage.services.list({
                                            parent: "projects/" + projectId,
                                            filter: 'state:ENABLED',
                                            pageSize: MAX_PAGE_SIZE,
                                        })];
                                case 3:
                                    list = _c.sent();
                                    serviceList = list.data.services || [];
                                    if (serviceList.length >= MAX_PAGE_SIZE) {
                                        console.log('Uh oh. It looks like Grant did not add pagination. Please create a bug.');
                                    }
                                    enabledAPIs = serviceList.filter(function (service) {
                                        return service.state === 'ENABLED';
                                    });
                                    for (_i = 0, enabledAPIs_1 = enabledAPIs; _i < enabledAPIs_1.length; _i++) {
                                        enabledAPI = enabledAPIs_1[_i];
                                        if (enabledAPI.config && enabledAPI.config.documentation) {
                                            name = enabledAPI.config.name || 'Unknown name.';
                                            console.log(name.substr(0, name.indexOf('.')) + " - " + enabledAPI.config.documentation.summary);
                                        }
                                    }
                                    /**
                                     * List available APIs.
                                     */
                                    console.log('\n# List of available APIs:');
                                    return [4 /*yield*/, auth_1.discovery.apis.list({
                                            preferred: true,
                                        })];
                                case 4:
                                    data = (_c.sent()).data;
                                    services = data.items || [];
                                    PUBLIC_ADVANCED_SERVICE_IDS = apis_1.PUBLIC_ADVANCED_SERVICES.map(function (advancedService) { return advancedService.serviceId; });
                                    publicServices = [];
                                    _loop_1 = function (publicServiceId) {
                                        var service = services.find(function (s) { return s.name === publicServiceId; });
                                        // for some reason 'youtubePartner' is not in the api list.
                                        if (service && service.id && service.description) {
                                            publicServices.push(service);
                                        }
                                    };
                                    for (_a = 0, PUBLIC_ADVANCED_SERVICE_IDS_1 = PUBLIC_ADVANCED_SERVICE_IDS; _a < PUBLIC_ADVANCED_SERVICE_IDS_1.length; _a++) {
                                        publicServiceId = PUBLIC_ADVANCED_SERVICE_IDS_1[_a];
                                        _loop_1(publicServiceId);
                                    }
                                    // Sort the services based on id
                                    publicServices.sort(function (a, b) {
                                        if (a.id < b.id)
                                            return -1;
                                        if (a.id > b.id)
                                            return 1;
                                        return 0;
                                    });
                                    // Format the list
                                    for (_b = 0, publicServices_1 = publicServices; _b < publicServices_1.length; _b++) {
                                        api = publicServices_1[_b];
                                        console.log(padEnd(api.name, 25) + " - " + padEnd(api.description, 60));
                                    }
                                    return [2 /*return*/];
                            }
                        });
                    }); },
                    undefined: function () {
                        command.list();
                        console.log("# Try these commands:\n- clasp apis list\n- clasp apis enable slides\n- clasp apis disable slides");
                    },
                };
                if (command[subcommand]) {
                    command[subcommand]();
                }
                else {
                    utils_1.logError(null, utils_1.ERROR.COMMAND_DNE('apis ' + subcommand));
                }
                return [2 /*return*/];
        }
    });
}); };
/**
 * Gets or sets a setting in .clasp.json
 * @param {keyof ProjectSettings} settingKey The key to set
 * @param {string?} settingValue Optional value to set the key to
 */
exports.setting = function (settingKey, settingValue) { return __awaiter(_this, void 0, void 0, function () {
    var currentSettings, keyValue, currentSettings_1, currentValue, e_1;
    return __generator(this, function (_a) {
        switch (_a.label) {
            case 0: return [4 /*yield*/, utils_1.getProjectSettings()];
            case 1:
                currentSettings = _a.sent();
                // Display all settings if ran `clasp setting`.
                if (!settingKey) {
                    console.log(currentSettings);
                    return [2 /*return*/];
                }
                if (!!settingValue) return [3 /*break*/, 2];
                if (settingKey in currentSettings) {
                    keyValue = currentSettings[settingKey];
                    if (Array.isArray(keyValue)) {
                        keyValue = keyValue.toString();
                    }
                    else if (typeof keyValue !== 'string') {
                        keyValue = '';
                    }
                    // We don't use console.log as it automatically adds a new line
                    // Which interfers with storing the value
                    process.stdout.write(keyValue);
                }
                else {
                    utils_1.logError(null, utils_1.ERROR.UNKNOWN_KEY(settingKey));
                }
                return [3 /*break*/, 6];
            case 2:
                _a.trys.push([2, 5, , 6]);
                return [4 /*yield*/, utils_1.getProjectSettings()];
            case 3:
                currentSettings_1 = _a.sent();
                currentValue = settingKey in currentSettings_1 ? currentSettings_1[settingKey] : '';
                switch (settingKey) {
                    case 'scriptId':
                        currentSettings_1.scriptId = settingValue;
                        break;
                    case 'rootDir':
                        currentSettings_1.rootDir = settingValue;
                        break;
                    case 'projectId':
                        currentSettings_1.projectId = settingValue;
                        break;
                    case 'fileExtension':
                        currentSettings_1.fileExtension = settingValue;
                        break;
                    default:
                        utils_1.logError(null, utils_1.ERROR.UNKNOWN_KEY(settingKey));
                }
                // filePushOrder doesn't work since it requires an array.
                // const filePushOrder = settingKey === 'filePushOrder' ? settingValue : currentSettings.filePushOrder;
                return [4 /*yield*/, utils_1.saveProject(currentSettings_1, true)];
            case 4:
                // filePushOrder doesn't work since it requires an array.
                // const filePushOrder = settingKey === 'filePushOrder' ? settingValue : currentSettings.filePushOrder;
                _a.sent();
                console.log("Updated \"" + settingKey + "\": \"" + currentValue + "\" \u2192 \"" + settingValue + "\"");
                return [3 /*break*/, 6];
            case 5:
                e_1 = _a.sent();
                utils_1.logError(null, 'Unable to update .clasp.json');
                return [3 /*break*/, 6];
            case 6: return [2 /*return*/];
        }
    });
}); };
